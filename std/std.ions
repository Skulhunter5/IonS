macro SYS_read 0
macro SYS_write 1

macro STDIN 0
macro STDOUT 1

macro fputs {
  SYS_write syscall3
}

macro puts {
  STDOUT fputs
}

proc cstrlen 1-1 {
	dup
	while { dup @8 } do ++
	swap -
}

macro cputs {
	dup cstrlen swap puts
}

macro clamp {
   rot min max
}

macro inc8 {
	dup @8 ++ swap !8
}
macro dec8 {
	dup @8 -- swap !8
}
macro inc16 {
	dup @16 ++ swap !16
}
macro dec16 {
	dup @16 -- swap !16
}
macro inc32 {
	dup @32 ++ swap !32
}
macro dec32 {
	dup @32 -- swap !32
}
macro inc64 {
	dup @64 ++ swap !64
}
macro dec64 {
	dup @64 -- swap !64
}

proc streq 4-1 {
	swap 2swap 2rot dup rot
	!= if {
		2drop drop
		0 return
	}
    dup 0 == if {
        2drop drop
        1 return
    }
    0 while { 2dup > } do {
        2swap 2rot 2dup + @8
        2swap 2dup + @8
        2swap 2rot != if {
            2drop 2drop
            0 return
        }
        rot 2swap
        ++
    }
    dup 0 > if {
        2drop 2drop
        1 return
    }
    0
}

proc cstreq 2-1 {
	dup cstrlen swap rot dup cstrlen swap streq
}

proc isAlpha 1-1 {
    dup 65 < swap
    dup 122 > rot || swap
    dup 90 > swap
    97 <
    && || not
}

proc isDigit 1-1 {
    dup 48 < swap
    57 >
    || not
}

proc isAlnum 1-1 {
    dup isAlpha swap
    isDigit
    ||
}

proc str-startswith 4-1 {
    swap 2swap 2rot
    2dup > if {
        2drop 2drop
        0 return
    }
    drop dup rot 2swap swap
    streq
}

proc str-endswith 4-1 {
    swap 2swap 2rot
    2dup > if {
        2drop 2drop
        0 return
    }
    over - rot +
    over swap 2swap swap
    streq
}

proc try-parse-uint64 3-1 { // TODO: fix it not going over the maximum uint64 value
    // len str ptr
    2rot swap
    // ptr str len
    dup 20 > if {
        2drop drop
        0 return
    }
    // ptr str len
    rot 0 over !64
    // str len ptr
    2rot
    // ptr str len
    0 while { 2dup > } do {
        // ptr str len i
        2swap swap dup @64 10 * over !64
        // len i str ptr
        swap 2swap
        // ptr str len i
        rot 2dup + @8
        // ptr len i str str[i]
        dup isDigit not if {
            // ptr len i str str[i]
            2drop 2drop drop
            0 return
        }
        // ptr len i str str[i]
        48 - rot5 dup @64 rot + over !64
        // len i str ptr
        swap 2swap
        // ptr str len i
        ++
    }
    // ptr str len i
    2drop 2drop
    1 return
}

proc memcpy 3-0 {
    // src dst size
    0 while { 2dup > } do {
        // src dst size i
        rot 2dup +
        // src size i dst (dst+i)
        rot rot5 2dup + @8
        // size dst (dst+i) i src src[i]
        2swap 2rot !8
        // size dst src i
        2swap 2rot swap
        // src dst size i
        ++
    }
    2drop 2drop
}

proc strcat 5-2 {
    // len1 str1 len2 str2 buf
    ctt4 over ctt7 memcpy
    // len1 str1 len2 str2 buf
    2dup ctt7 + ctt5 memcpy
    // len1 str1 len2 str2 buf
    2rot5 drop swap drop + swap
    // len1+len2 buf
}
