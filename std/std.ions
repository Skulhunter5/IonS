macro SYS_read 0
macro SYS_write 1
macro SYS_openat 257

macro STDIN 0
macro STDOUT 1

macro O_RDONLY 0
macro O_WRONLY 1
macro O_RDWR 2
macro O_CREAT 0100
macro O_EXCL 0200
macro O_NOCTTY 0400
macro O_TRUNC 01000
macro O_APPEND 02000

macro AT_FDCWD { 0 100 - }

macro MAP_PRIVATE 0x02
macro MAP_ANONYMOUS 0x20

macro PROT_READ 0x1
macro PROT_WRITE 0x2
macro PROT_EXEC 0x4

macro sizeof(bool) 1
macro sizeof(uint) 8
macro sizeof(uint64) 8
macro sizeof(ptr) 8

inline proc fputs ( uint64 ptr uint64 -- uint64 ) {
    SYS_write syscall3
}

inline proc puts ( uint64 ptr ) {
    STDOUT fputs drop
}

inline proc putc ( ptr ) {
    1 swap puts
}

inline proc openat ( uint64 ptr uint64 uint64 -- uint64 ) {
    SYS_openat syscall4
}

macro sizeof(Str) 16
proc !Str ( uint64 ptr ptr ) {
    rot over !64
    cast(uint64) 8 + cast(ptr)
    swap cast(uint64) swap !64
}
proc @Str ( ptr -- uint64 ptr ) {
    dup @64
    swap
    cast(uint64) 8 + cast(ptr) @64
}

proc cstrlen ( ptr -- uint64 ) {
    cast(uint64)
	dup
	while { dup cast(ptr) @8 cast(bool) } do {
        ++
    }
	swap -
}

inline proc cputs ( ptr ) {
	dup cstrlen swap puts
}

inline proc clamp ( uint64 uint64 uint64 -- uint64 ) {
    rot min max
}

inline proc inc8 ( ptr ) {
	dup @8 ++ swap !8
}
inline proc dec8 ( ptr ) {
	dup @8 -- swap !8
}
inline proc inc16 ( ptr ) {
	dup @16 ++ swap !16
}
inline proc dec16 ( ptr ) {
	dup @16 -- swap !16
}
inline proc inc32 ( ptr ) {
	dup @32 ++ swap !32
}
inline proc dec32 ( ptr ) {
	dup @32 -- swap !32
}
inline proc inc64 ( ptr ) {
	dup @64 ++ swap !64
}
inline proc dec64 ( ptr ) {
	dup @64 -- swap !64
}

proc streq ( uint64 ptr uint64 ptr -- bool ) {
	swap 2swap rrot dup rot
	!= if {
		2drop drop
		false return
	}
    dup 0 == if {
        2drop drop
        true return
    }
    0 while { 2dup > } do {
        2swap rrot 2dup + @8
        2swap 2dup + @8
        2swap rrot != if {
            2drop 2drop
            false return
        }
        rot 2swap
        ++
    }
    dup 0 > if {
        2drop 2drop
        true return
    }
    false
}

proc cstreq ( ptr ptr -- bool ) {
	dup cstrlen swap rot dup cstrlen swap streq
}

proc isAlpha ( uint64 -- bool ) {
    dup 65 < swap
    dup 122 > rot || swap
    dup 90 > swap
    97 <
    && || not
}

proc isDigit ( uint64 -- bool ) {
    dup 48 < swap
    57 >
    || not
}

proc isAlnum ( uint64 -- bool ) {
    dup isAlpha swap
    isDigit
    ||
}

proc str-startswith ( uint64 ptr uint64 ptr -- bool ) {
    swap 2swap rrot
    2dup > if {
        2drop 2drop
        false return
    }
    drop dup rot 2swap swap
    streq
}

proc str-endswith ( uint64 ptr uint64 ptr -- bool ) {
    swap 2swap rrot
    2dup > if {
        2drop 2drop
        false return
    }
    over - rot +
    over swap 2swap swap
    streq
}

proc try-parse-uint64 ( uint64 ptr ptr -- bool ) { // TODO: fix it not going over the maximum uint64 value
    // len str ptr
    rrot swap
    // ptr str len
    dup 20 > if {
        2drop drop
        false return
    }
    // ptr str len
    rot 0 over !64
    // str len ptr
    rrot
    // ptr str len
    0 while { 2dup > } do {
        // ptr str len i
        2swap swap dup @64 10 * over !64
        // len i str ptr
        swap 2swap
        // ptr str len i
        rot 2dup + @8
        // ptr len i str str[i]
        dup isDigit not if {
            // ptr len i str str[i]
            2drop 2drop drop
            false return
        }
        // ptr len i str str[i]
        48 - rot5 dup @64 rot + over !64
        // len i str ptr
        swap 2swap
        // ptr str len i
        ++
    }
    // ptr str len i
    2drop 2drop
    true return
}

proc memcpy8 ( ptr ptr uint64 ) {
    rrot swap rot
    0 while { 2dup > } do {
        rot 2dup cast(uint64) +
        rot rot5 2dup cast(uint64) + cast(ptr) @8
        2swap rrot cast(ptr) !8
        2swap rrot swap
        ++
    }
    2drop 2drop
}

proc memcpy16 ( ptr ptr uint64 ) {
    rrot swap rot
    0 while { 2dup > } do {
        rot 2dup cast(uint64) +
        rot rot5 2dup cast(uint64) + cast(ptr) @16
        2swap rrot cast(ptr) !16
        2swap rrot swap
        2 +
    }
    2drop 2drop
}

proc memcpy32 ( ptr ptr uint64 ) {
    rrot swap rot
    0 while { 2dup > } do {
        rot 2dup cast(uint64) +
        rot rot5 2dup cast(uint64) + cast(ptr) @32
        2swap rrot cast(ptr) !32
        2swap rrot swap
        4 +
    }
    2drop 2drop
}

proc memcpy64 ( ptr ptr uint64 ) {
    rrot swap rot
    0 while { 2dup > } do {
        rot 2dup cast(uint64) +
        rot rot5 2dup cast(uint64) + cast(ptr) @64
        2swap rrot cast(ptr) !64
        2swap rrot swap
        8 +
    }
    2drop 2drop
}

proc memcpy ( ptr ptr uint64 ) {
    // dest src n
    8 /% swap 8 *
    // dest src n%8 n//8*8
    swap over
    // dest src n//8*8 n%8 n//8*8
    ctt5 ctt5
    // dest src n//8*8 n%8 n//8*8 dest src
    rrot over +
    // dest src n//8*8 n%8 src n//8*8 ndest
    rrot +
    // dest src n//8*8 n%8 ndest nsrc
    rot memcpy8
    // dest src n//8*8
    memcpy64
    // 
}

proc strcat ( uint64 ptr uint64 ptr ptr -- uint64 ptr ) {
    ctt4 over ctt7 memcpy
    2dup cast(uint64) ctt7 + cast(ptr) ctt5 memcpy
    rrot5 drop swap drop + swap
}
